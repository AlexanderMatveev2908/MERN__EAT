import { Response } from "express";
import { RequestWithUserId } from "../../middleware/general/verifyAccessToken.js";
import { checkUserProperty } from "../../utils/checkers/myRestaurants.js";
import User from "../../models/User.js";
import mongoose from "mongoose";
import { makeQueriesMyRestaurants } from "../../utils/makeQueries/myRestaurants.js";
import { makeSortersMyRestaurants } from "../../utils/makeSorters/myRestaurants.js";
import Restaurant from "../../models/Restaurant.js";
import { calcPagination } from "../../utils/calcPagination.js";
import { makeOrdersStatusFields } from "../../utils/dbPipeline/myRestaurants.js";
import { makeLookUp } from "../../utils/dbPipeline/general.js";

export const getMyRestaurants = async (
  req: RequestWithUserId,
  res: Response
): Promise<any> => {
  const { userId } = req;

  const query = makeQueriesMyRestaurants(req);

  const sorter = makeSortersMyRestaurants(req);

  const totDocuments = await Restaurant.countDocuments({
    owner: new mongoose.Types.ObjectId(userId),
  });

  const { limit, skip, totPages } = calcPagination(req, totDocuments);

  const result = await User.aggregate([
    // search user restaurants by his id string converted to ObjectId for mongo
    { $match: { _id: new mongoose.Types.ObjectId(userId) } },
    // i choose to challenge myself by using more nested collections, and to get vals from another collections we use first: the local field is the fields that we keep as ref for that other collection documents we want , so  for user i have an arr of ref id in restaurants key, but from point of view of each restaurant, he has just just a simple _id that for him is the one generated by mongoose but for us, the id with we update the user arr for each create or delete
    {
      $lookup: {
        from: "restaurants",
        localField: "restaurants",
        foreignField: "_id",
        as: "restaurants",
      },
    },
    // with unwind we can process each el similar to a map in js
    { $unwind: "$restaurants" },
    // we add necessary fields here to not do it in frontend and get values already processed
    makeLookUp("restaurants", "dishes"),
    {
      $set: {
        "restaurants.dishesCount": { $size: "$restaurants.dishes" },
        "restaurants.avgPrice": {
          $ifNull: [
            {
              $avg: {
                $map: {
                  input: { $ifNull: ["$restaurants.dishes", []] },
                  as: "dish",
                  in: { $ifNull: ["$$dish.price", 0] },
                },
              },
            },
            0,
          ],
        },
      },
    },

    makeLookUp("restaurants", "orders"),
    {
      $set: {
        "restaurants.ordersCount": { $size: "$restaurants.orders" },
        ...makeOrdersStatusFields(),
      },
    },

    makeLookUp("restaurants", "reviews"),
    {
      $set: {
        "restaurants.reviewsCount": { $size: "$restaurants.reviews" },
        "restaurants.avgRating": {
          $ifNull: [
            {
              $avg: {
                $map: {
                  input: { $ifNull: ["$restaurants.reviews", []] },
                  as: "review",
                  in: { $ifNull: ["$$review.rating", 0] },
                },
              },
            },
            0,
          ],
        },
      },
    },

    ...(query ? [{ $match: query }] : []),
    // make our operations of sorting before group cause after is not possible modifying their order
    ...(sorter ? [{ $sort: sorter }] : []),
    // after unwind we need an array of els again cause is easier to work with
    { $skip: skip },
    { $limit: limit },
    {
      $group: {
        _id: "$_id",
        restaurants: { $push: "$restaurants" },
        nHits: { $sum: 1 },
      },
    },
    {
      $project: {
        _id: 0,
        "restaurants.dishes": 0,
        "restaurants.orders": 0,
        "restaurants.reviews": 0,
      },
    },
    // facet runs multiples query in parallel so is pretty fast but they must be independent one by other
  ]);
  // most of cases $ is used for dynamic fields, to access property of obj and create new fields, in some way is similar with THIS in oop js

  const restaurants = result[0]?.restaurants;
  const nHits = result[0]?.nHits;

  console.log(restaurants);

  // console.log(restaurants);
  return res.status(200).json({
    success: true,
    restaurants,
    totDocuments,
    totPages,
    nHits,
  });
};

export const getMySingleRestaurant = async (
  req: RequestWithUserId,
  res: Response
): Promise<any> => {
  const { user, restaurant } = await checkUserProperty(req, res);
  if ([user, restaurant].some((el) => !el)) return;

  return res.status(200).json({ success: true, restaurant });
};
